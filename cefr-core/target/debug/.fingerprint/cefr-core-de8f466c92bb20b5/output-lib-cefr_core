{"$message_type":"diagnostic","message":"enum is not supported in `trait`s or `impl`s","code":null,"level":"error","spans":[{"file_name":"src\\syntax.rs","byte_start":5825,"byte_end":5840,"line_start":152,"line_end":152,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"    enum ClauseType {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider moving the enum out to a nearby module scope","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\syntax.rs:152:5: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m: enum is not supported in `trait`s or `impl`s\u001b[0m\n"}
{"$message_type":"diagnostic","message":"unexpected `cfg` condition value: `console_error_panic_hook`","code":{"code":"unexpected_cfgs","explanation":null},"level":"warning","spans":[{"file_name":"src\\lib.rs","byte_start":6536,"byte_end":6572,"line_start":200,"line_end":200,"column_start":11,"column_end":47,"is_primary":true,"text":[{"text":"    #[cfg(feature = \"console_error_panic_hook\")]","highlight_start":11,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"no expected values for `feature`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider adding `console_error_panic_hook` as a feature in `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`#[warn(unexpected_cfgs)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the condition","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":6536,"byte_end":6572,"line_start":200,"line_end":200,"column_start":11,"column_end":47,"is_primary":true,"text":[{"text":"    #[cfg(feature = \"console_error_panic_hook\")]","highlight_start":11,"highlight_end":47}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\lib.rs:200:11: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m: unexpected `cfg` condition value: `console_error_panic_hook`: help: remove the condition\u001b[0m\n"}
{"$message_type":"diagnostic","message":"ambiguous associated type","code":{"code":"E0223","explanation":"An attempt was made to retrieve an associated type, but the type was ambiguous.\n\nErroneous code example:\n\n```compile_fail,E0223\ntrait Trait { type X; }\n\nfn main() {\n    let foo: Trait::X;\n}\n```\n\nThe problem here is that we're attempting to take the associated type of `X`\nfrom `Trait`. Unfortunately, the type of `X` is not defined, because it's only\nmade concrete in implementations of the trait. A working version of this code\nmight look like:\n\n```\ntrait Trait { type X; }\n\nstruct Struct;\nimpl Trait for Struct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <Struct as Trait>::X;\n}\n```\n\nThis syntax specifies that we want the associated type `X` from `Struct`'s\nimplementation of `Trait`.\n\nDue to internal limitations of the current compiler implementation we cannot\nsimply use `Struct::X`.\n"},"level":"error","spans":[{"file_name":"src\\syntax.rs","byte_start":6377,"byte_end":6393,"line_start":164,"line_end":164,"column_start":32,"column_end":48,"is_primary":true,"text":[{"text":"            let mut stack: Vec<Self::ClauseType> = Vec::new();","highlight_start":32,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if there were a trait named `Example` with associated type `ClauseType` implemented for `SyntacticAnalyzer`, you could use the fully-qualified path","code":null,"level":"help","spans":[{"file_name":"src\\syntax.rs","byte_start":6377,"byte_end":6393,"line_start":164,"line_end":164,"column_start":32,"column_end":48,"is_primary":true,"text":[{"text":"            let mut stack: Vec<Self::ClauseType> = Vec::new();","highlight_start":32,"highlight_end":48}],"label":null,"suggested_replacement":"<SyntacticAnalyzer as Example>::ClauseType","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\syntax.rs:164:32: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0223]\u001b[0m\u001b[0m: ambiguous associated type\u001b[0m\n"}
{"$message_type":"diagnostic","message":"ambiguous associated type","code":{"code":"E0223","explanation":"An attempt was made to retrieve an associated type, but the type was ambiguous.\n\nErroneous code example:\n\n```compile_fail,E0223\ntrait Trait { type X; }\n\nfn main() {\n    let foo: Trait::X;\n}\n```\n\nThe problem here is that we're attempting to take the associated type of `X`\nfrom `Trait`. Unfortunately, the type of `X` is not defined, because it's only\nmade concrete in implementations of the trait. A working version of this code\nmight look like:\n\n```\ntrait Trait { type X; }\n\nstruct Struct;\nimpl Trait for Struct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <Struct as Trait>::X;\n}\n```\n\nThis syntax specifies that we want the associated type `X` from `Struct`'s\nimplementation of `Trait`.\n\nDue to internal limitations of the current compiler implementation we cannot\nsimply use `Struct::X`.\n"},"level":"error","spans":[{"file_name":"src\\syntax.rs","byte_start":7033,"byte_end":7049,"line_start":176,"line_end":176,"column_start":32,"column_end":48,"is_primary":true,"text":[{"text":"                    stack.push(Self::ClauseType::Explicit);","highlight_start":32,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if there were a trait named `Example` with associated type `ClauseType` implemented for `SyntacticAnalyzer`, you could use the fully-qualified path","code":null,"level":"help","spans":[{"file_name":"src\\syntax.rs","byte_start":7033,"byte_end":7049,"line_start":176,"line_end":176,"column_start":32,"column_end":48,"is_primary":true,"text":[{"text":"                    stack.push(Self::ClauseType::Explicit);","highlight_start":32,"highlight_end":48}],"label":null,"suggested_replacement":"<SyntacticAnalyzer as Example>::ClauseType","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\syntax.rs:176:32: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0223]\u001b[0m\u001b[0m: ambiguous associated type\u001b[0m\n"}
{"$message_type":"diagnostic","message":"ambiguous associated type","code":{"code":"E0223","explanation":"An attempt was made to retrieve an associated type, but the type was ambiguous.\n\nErroneous code example:\n\n```compile_fail,E0223\ntrait Trait { type X; }\n\nfn main() {\n    let foo: Trait::X;\n}\n```\n\nThe problem here is that we're attempting to take the associated type of `X`\nfrom `Trait`. Unfortunately, the type of `X` is not defined, because it's only\nmade concrete in implementations of the trait. A working version of this code\nmight look like:\n\n```\ntrait Trait { type X; }\n\nstruct Struct;\nimpl Trait for Struct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <Struct as Trait>::X;\n}\n```\n\nThis syntax specifies that we want the associated type `X` from `Struct`'s\nimplementation of `Trait`.\n\nDue to internal limitations of the current compiler implementation we cannot\nsimply use `Struct::X`.\n"},"level":"error","spans":[{"file_name":"src\\syntax.rs","byte_start":7690,"byte_end":7706,"line_start":187,"line_end":187,"column_start":40,"column_end":56,"is_primary":true,"text":[{"text":"                            stack.push(Self::ClauseType::Implicit);","highlight_start":40,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if there were a trait named `Example` with associated type `ClauseType` implemented for `SyntacticAnalyzer`, you could use the fully-qualified path","code":null,"level":"help","spans":[{"file_name":"src\\syntax.rs","byte_start":7690,"byte_end":7706,"line_start":187,"line_end":187,"column_start":40,"column_end":56,"is_primary":true,"text":[{"text":"                            stack.push(Self::ClauseType::Implicit);","highlight_start":40,"highlight_end":56}],"label":null,"suggested_replacement":"<SyntacticAnalyzer as Example>::ClauseType","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\syntax.rs:187:40: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0223]\u001b[0m\u001b[0m: ambiguous associated type\u001b[0m\n"}
{"$message_type":"diagnostic","message":"ambiguous associated type","code":{"code":"E0223","explanation":"An attempt was made to retrieve an associated type, but the type was ambiguous.\n\nErroneous code example:\n\n```compile_fail,E0223\ntrait Trait { type X; }\n\nfn main() {\n    let foo: Trait::X;\n}\n```\n\nThe problem here is that we're attempting to take the associated type of `X`\nfrom `Trait`. Unfortunately, the type of `X` is not defined, because it's only\nmade concrete in implementations of the trait. A working version of this code\nmight look like:\n\n```\ntrait Trait { type X; }\n\nstruct Struct;\nimpl Trait for Struct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <Struct as Trait>::X;\n}\n```\n\nThis syntax specifies that we want the associated type `X` from `Struct`'s\nimplementation of `Trait`.\n\nDue to internal limitations of the current compiler implementation we cannot\nsimply use `Struct::X`.\n"},"level":"error","spans":[{"file_name":"src\\syntax.rs","byte_start":8282,"byte_end":8298,"line_start":198,"line_end":198,"column_start":36,"column_end":52,"is_primary":true,"text":[{"text":"                        stack.push(Self::ClauseType::Reduced);","highlight_start":36,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if there were a trait named `Example` with associated type `ClauseType` implemented for `SyntacticAnalyzer`, you could use the fully-qualified path","code":null,"level":"help","spans":[{"file_name":"src\\syntax.rs","byte_start":8282,"byte_end":8298,"line_start":198,"line_end":198,"column_start":36,"column_end":52,"is_primary":true,"text":[{"text":"                        stack.push(Self::ClauseType::Reduced);","highlight_start":36,"highlight_end":52}],"label":null,"suggested_replacement":"<SyntacticAnalyzer as Example>::ClauseType","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\syntax.rs:198:36: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0223]\u001b[0m\u001b[0m: ambiguous associated type\u001b[0m\n"}
{"$message_type":"diagnostic","message":"ambiguous associated type","code":{"code":"E0223","explanation":"An attempt was made to retrieve an associated type, but the type was ambiguous.\n\nErroneous code example:\n\n```compile_fail,E0223\ntrait Trait { type X; }\n\nfn main() {\n    let foo: Trait::X;\n}\n```\n\nThe problem here is that we're attempting to take the associated type of `X`\nfrom `Trait`. Unfortunately, the type of `X` is not defined, because it's only\nmade concrete in implementations of the trait. A working version of this code\nmight look like:\n\n```\ntrait Trait { type X; }\n\nstruct Struct;\nimpl Trait for Struct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <Struct as Trait>::X;\n}\n```\n\nThis syntax specifies that we want the associated type `X` from `Struct`'s\nimplementation of `Trait`.\n\nDue to internal limitations of the current compiler implementation we cannot\nsimply use `Struct::X`.\n"},"level":"error","spans":[{"file_name":"src\\syntax.rs","byte_start":10161,"byte_end":10177,"line_start":235,"line_end":235,"column_start":44,"column_end":60,"is_primary":true,"text":[{"text":"                        if *clause_type != Self::ClauseType::Explicit {","highlight_start":44,"highlight_end":60}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if there were a trait named `Example` with associated type `ClauseType` implemented for `SyntacticAnalyzer`, you could use the fully-qualified path","code":null,"level":"help","spans":[{"file_name":"src\\syntax.rs","byte_start":10161,"byte_end":10177,"line_start":235,"line_end":235,"column_start":44,"column_end":60,"is_primary":true,"text":[{"text":"                        if *clause_type != Self::ClauseType::Explicit {","highlight_start":44,"highlight_end":60}],"label":null,"suggested_replacement":"<SyntacticAnalyzer as Example>::ClauseType","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0msrc\\syntax.rs:235:44: \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9merror[E0223]\u001b[0m\u001b[0m: ambiguous associated type\u001b[0m\n"}
{"$message_type":"diagnostic","message":"aborting due to 6 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m: aborting due to 6 previous errors; 1 warning emitted\u001b[0m\n"}
